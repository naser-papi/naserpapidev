name: Deploy to VPS (Caddy + Docker Compose)

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

concurrency:
  group: deploy-prod
  cancel-in-progress: true

permissions:
  contents: read
  packages: write

env:
  IMAGE_NAME: naserpapidev

jobs:
  build_and_push:
    name: Build & Push Image
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Read .env.deploy into env
        id: read_env
        run: |
          set -euo pipefail
          if [ -f ".env.deploy" ]; then
            set -a && . ./.env.deploy && set +a
            {
              echo "DOMAIN=${DOMAIN:-}"
              echo "EMAIL=${EMAIL:-}"
              echo "DATABASE_URL=${DATABASE_URL:-}"
              echo "API_SERVER=${API_SERVER:-}"
              echo "NEXT_PUBLIC_API_SERVER=${NEXT_PUBLIC_API_SERVER:-}"
              echo "SHOW_CONSTRUCTION=${SHOW_CONSTRUCTION:-}"
              echo "GHCR_OWNER_FILE=${GHCR_OWNER:-}"
              echo "IMAGE_TAG_FILE=${IMAGE_TAG:-latest}"
            } >> "$GITHUB_ENV"
          else
            echo "::warning:: .env.deploy not found; continuing with secrets-only"
          fi

      - name: Set image tags
        id: tags
        run: |
          OWNER="${{ github.repository_owner }}"
          SHA_TAG="${{ github.sha }}"
          echo "OWNER=${OWNER}" >> $GITHUB_ENV
          echo "SHA_TAG=${SHA_TAG}" >> $GITHUB_ENV
          echo "IMAGE_SHA=ghcr.io/${OWNER}/${{ env.IMAGE_NAME }}:${SHA_TAG}" >> $GITHUB_ENV
          echo "IMAGE_LATEST=ghcr.io/${OWNER}/${{ env.IMAGE_NAME }}:latest" >> $GITHUB_ENV

      - name: Log in to GHCR
        run: echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u "${{ github.actor }}" --password-stdin

      - name: Build image (bake in NEXT_PUBLIC_* at build time)
        run: |
          BUILD_NEXT_PUBLIC_API_SERVER="${{ secrets.NEXT_PUBLIC_API_SERVER }}"
          if [ -z "$BUILD_NEXT_PUBLIC_API_SERVER" ]; then
            BUILD_NEXT_PUBLIC_API_SERVER="${NEXT_PUBLIC_API_SERVER:-}"
          fi

          docker build \
            --build-arg NEXT_PUBLIC_API_SERVER="$BUILD_NEXT_PUBLIC_API_SERVER" \
            -t "${IMAGE_SHA}" \
            -t "${IMAGE_LATEST}" \
            .

      - name: Push image
        run: |
          docker push "${IMAGE_SHA}"
          docker push "${IMAGE_LATEST}"

  deploy:
    name: Deploy on VPS
    runs-on: ubuntu-latest
    needs: [ build_and_push ]

    env:
      GHCR_OWNER: ${{ github.repository_owner }}
      IMAGE_TAG: ${{ github.sha }}

    steps:
      - name: Checkout (for rsync of compose/ops files)
        uses: actions/checkout@v4

      # Validate and normalize secrets to avoid blank host or hidden CR/LF
      - name: Preflight & normalize
        env:
          DEPLOY_SSH: ${{ secrets.DEPLOY_SSH }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
          DEPLOY_PORT: ${{ secrets.DEPLOY_PORT }}
        run: |
          set -euo pipefail
          # Required secrets
          [ -n "$SSH_PRIVATE_KEY" ] || { echo "::error:: Missing SSH_PRIVATE_KEY secret"; exit 1; }
          [ -n "$DEPLOY_SSH" ] || { echo "::error:: Missing DEPLOY_SSH (expected user@host or user@IP)"; exit 1; }
          [ -n "$DEPLOY_PATH" ] || { echo "::error:: Missing DEPLOY_PATH (e.g., /srv/naserpapidev)"; exit 1; }

          # Trim whitespace/newlines/tabs from host
          HOST="$(printf '%s' "$DEPLOY_SSH" | tr -d '\r\n' | sed 's/[[:space:]]//g')"
          echo "$HOST" | grep -Eq '^[^@]+@[^@]+$' || { echo "::error:: DEPLOY_SSH must look like user@host (got: $HOST)"; exit 1; }
          echo "::add-mask::$HOST"
          echo "HOST=$HOST" >> $GITHUB_ENV

          REMOTE_PATH="$(printf '%s' "$DEPLOY_PATH" | tr -d '\r\n')"
          echo "REMOTE_PATH=$REMOTE_PATH" >> $GITHUB_ENV

          PORT_OPT=""
          if [ -n "${DEPLOY_PORT:-}" ]; then PORT_OPT="-p ${DEPLOY_PORT}"; fi
          echo "PORT_OPT=$PORT_OPT" >> $GITHUB_ENV

      - name: Setup SSH agent
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Prepare remote workspace (fix bad paths & ownership)
        run: |
          set -euo pipefail
          SSH_OPTS="-o StrictHostKeyChecking=no ${{ env.PORT_OPT }}"
          ssh $SSH_OPTS "${{ env.HOST }}" bash <<'S'
            set -euo pipefail
            DEPLOY_PATH="${{ env.REMOTE_PATH }}"
            BAD_DIR="$DEPLOY_PATH/ops/caddy/Caddyfile"

            mkdir -p "$DEPLOY_PATH"

            # If Caddyfile exists as a directory, remove it (try without sudo, then with sudo)
            if [ -d "$BAD_DIR" ]; then
              rm -rf "$BAD_DIR" || sudo rm -rf "$BAD_DIR"
            fi

            # Ensure expected dirs exist
            mkdir -p "$DEPLOY_PATH/ops/caddy"

            # Ensure deploy owns the tree (try without sudo, then with sudo)
            chown -R "$(id -un)":"$(id -gn)" "$DEPLOY_PATH" 2>/dev/null || sudo chown -R "$(id -un)":"$(id -gn)" "$DEPLOY_PATH" || true
          S

      - name: Rsync runtime files to VPS
        run: |
          set -euo pipefail
          SSH_OPTS="-o StrictHostKeyChecking=no ${{ env.PORT_OPT }}"
          # Ensure remote path exists
          ssh $SSH_OPTS "${{ env.HOST }}" "mkdir -p '${{ env.REMOTE_PATH }}'"
          # Sync compose, ops, and env template
          rsync -az --delete -e "ssh $SSH_OPTS" \
            docker-compose.yml \
            ops/ \
            .env.deploy \
            "${{ env.HOST }}:${{ env.REMOTE_PATH }}/"

      - name: Deploy (compose pull & up)
        env:
          DOMAIN: ${{ secrets.DOMAIN }}
          EMAIL: ${{ secrets.EMAIL }}
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          API_SERVER: ${{ secrets.API_SERVER }}
          NEXT_PUBLIC_API_SERVER: ${{ secrets.NEXT_PUBLIC_API_SERVER }}
          SHOW_CONSTRUCTION: ${{ secrets.SHOW_CONSTRUCTION }}
          GHCR_READ_TOKEN: ${{ secrets.GHCR_READ_TOKEN }}
        run: |
          set -euo pipefail
          ssh -o StrictHostKeyChecking=no ${{ env.PORT_OPT }} "${{ env.HOST }}" bash <<'EOF'
            set -euo pipefail
            cd "${{ env.REMOTE_PATH }}"

            # 1) Start from repo .env.deploy, then override
            if [ -f ".env.deploy" ]; then
              cp .env.deploy .env
            else
              : > .env
            fi

            # 2) Force image info
            {
              echo "GHCR_OWNER=${{ env.GHCR_OWNER }}"
              echo "IMAGE_TAG=${{ env.IMAGE_TAG }}"
            } >> .env

            # 3) Override from secrets if present
            append_if_set () {
              VAR_NAME="$1"; VAR_VALUE="$2"
              if [ -n "$VAR_VALUE" ]; then
                sed -i "/^${VAR_NAME}=.*/d" .env || true
                printf "%s=%s\n" "$VAR_NAME" "$VAR_VALUE" >> .env
              fi
            }
            append_if_set "DOMAIN" "${DOMAIN:-}"
            append_if_set "EMAIL" "${EMAIL:-}"
            append_if_set "DATABASE_URL" "${DATABASE_URL:-}"
            append_if_set "API_SERVER" "${API_SERVER:-}"
            append_if_set "NEXT_PUBLIC_API_SERVER" "${NEXT_PUBLIC_API_SERVER:-}"
            append_if_set "SHOW_CONSTRUCTION" "${SHOW_CONSTRUCTION:-}"

            # 4) GHCR auth for private packages (optional)
            if [ -n "${GHCR_READ_TOKEN:-}" ]; then
              echo "${GHCR_READ_TOKEN}" | docker login ghcr.io -u "${{ env.GHCR_OWNER }}" --password-stdin
            fi

            # 5) Pull & restart
            docker compose pull
            docker compose up -d --remove-orphans
            docker compose ps
          EOF
